JOURNAL DE BORD 
PROJET POO PH BA2 
DAVID ROSSBOTH, LEONARD LEBRUN


Chapitre 1:     27/02/2020
  
  L'aventure peut commencer. Les programmeurs se sont coordonnés via les outils Github et Gitbash, c'est donc armés jusqu'aux dents
  qu'ils répondent à l'appel.


Chapitre 2:     28/02/2020

  C'est donc après un premier jour de préparation, que nous avons commencé à coder. Le fichier Vecteur.h définissant la classe Vecteur
  a été écrit en premier, favorisant avant tout la simplicité et la sobriété, supposant que ce soit une classe fondamentale du projet.
  Ceci permettra de ne pas avoir de détails superflus (comme des unités) dont on devrait prendre compte durant le reste de la conception.
  Après une première écriture de Vecteur.cpp entreprise par David, Leonard a nettement amélioré le code pour parvenir à la dernière
  version du code.
  Leonard, motivé, a essayé de maîtriser une interface graphique. Bilan mitigé toutefois.

  Dans la soirée, Léonard s'intéresse à la surcherge d'opérateur pour améliorer la maniabilité des vecteurs.


Chapitre 3:	05.03.2020
  
  Durant les jours qui se sont écoulés depuis la dernière mise-à-jour, nous avons essayé de paufiner Vecteur.cpp et son header pour
  que les opérateurs +=, -= et *= marchent. Une fois leur efficacité démontrée, nous avons remplacé le corps des opérateurs +, - et *
  pour qu'ils dépendent des opérations élémentaires récemment créées.

  Ainsi, les seuls moyens de faire des opérations arithmétiques sur les vecteurs sont les opérateurs surchargés.

  Nous sommes donc heureux de pouvoir passer à la suite, sachant que notre classe Vecteur est opérationnelle.


Chapitre 4:    08.03.2020

  Ainsi, nous avons travaillé sur les méthodes en lien avec les matrices 3x3. Léonard a commencé par écrire les méthodes les plus
  simples (*= pour la multipliction par scalaire, +=, etc) en les inscrivant directement sous forme d'opérateur. Il s'est aussi chargé
  de la création des constructeurs pour les Matrice3.

  Une fois qu'il avait terminé, David s'est posé la question de comment créer les méthodes det() et surtout inv(). Il s'est donc plongé
  dans son cours d'algèbre. Il savait que la méthode la plus simple de procéder aurait juste été de faire une énorme formule pleine de
  copier-coller. Mais cela aurait été inintéressant.

  Le corps de la méthode det() est assez simple. Le déterminant est défini comme étant la somme sur les permutations sigma du groupe
  symétrique d'ordre n de sgn(sigma) multiplié par le produit des A[i][sigma[i]]. Or, toute permutation paire de S_3 est une boucle (1,2,3)
  étant décalée (i.e (2,3,1) et (3,1,2)), tandis qu'une permutation impaire est une permutation où deux des éléments sont iterchangés (En
  effet, les permutations impaires sont (2,1,3), (3,2,1) et (1,3,2)). Ainsi, à l'aide des modulos, nous arrivons à transcrire cette idée.
  En effet, les permutations paires s'écrivent (k%3, (1+k)%3, (2+k)%3) et les impaires ((1+k)%3, k%3, (2+k)%3). d'où le corps de det().

  Pour inv(), les choses se compliquent encore un peu plus. Nous avons écrit la méthode via les cofacteurs et d'une telle façon de que
  l'algorithme est seulement fait en 9 étapes (les 9 cases de la matrice) alors qu'il serait de 27 étapes si codé autrement (calcul du
  déterminant non-compris).
  Quand nous calculons une matrice des cofacteurs à la main, nous nous occupons d'abord du contenu de la case, puis de son signe, puis de la transposer.
  Expliquons donc ceci dans cet ordre.
  Quand nous calculons la case de la matrice des cofacteurs, nous "cachons" les lignes et colonnes de la matrice dont on veut calculer l'inverse.
  Ceci veut dire que si nous calculons Cof(A)[0][1], alors nous prenons les cases A[1][0], A[2][0], A[1][2] et A[2][2] pour calculer un determinant
  avec (nous sommes passé à une notation informatique). Notons que 1=(0+1)%3 et 2=(0-1)%3 (en maths).
  C'est donc ceci que nous faisons. Cof(A)[k][t]=produit des max et min de (k+-1)%3 et (t+-1)%3 - le produit du max et du min. Or, en c++, le modulo est à
  valeur négative. Donc si c'est négatif, c'est forcément -1. Il faut alors changer le min en l'ancienne valeur du max et que le max ait la valeur 2
  (car 2 est la valeur maximale, et c'est impossible que nous ayons 2 fois la même valeur).
  Une fois ceci fait, il faut s'occuper du signe. Il est (-1)^(i+j) où i,j appartiennent à {1,2,3} en maths. Or dans le code, k et t appartiennent à
  {0,1,2}. Nous nous retrouvons donc avec (-1)^((k+1)+(t+1))=(-1)^(k+t+2)=(-1)^(k+t)*(-1)^2=(-1)^(k+t), qui est le facteur devant le déterminant.
  Nous avons donc, à ce stade, la matrice des cofacteurs, Cof(A).
  Pour reprendre la formule, il ne reste plus qu'à transposer la matrice pour avoir la matrice inverse. Donc il nous suffit de dire que
  Cof(A^T)[k][t]=Cof(A)[t][k] et de multiplier Cof(A^T) par 1/det(A).

  














  

